// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg_id.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_5fid_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_msg_5fid_2eproto

#include <proto.hpp>
#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_msg_5fid_2eproto PROTO_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct PROTO_API TableStruct_msg_5fid_2eproto {
  static const uint32_t offsets[];
};
PROTO_API extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_msg_5fid_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace game {

enum message_type : int {
  msg_c2s_req = 0,
  msg_s2c_ack = 4096,
  msg_c2s_brd = 8192,
  msg_s2c_brd = 12288,
  msg_s2s_req = 16384,
  msg_s2s_ack = 20480,
  msg_s2s_brd = 24576,
  msg_mask = 61440,
  message_type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  message_type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
PROTO_API bool message_type_IsValid(int value);
constexpr message_type message_type_MIN = msg_c2s_req;
constexpr message_type message_type_MAX = msg_mask;
constexpr int message_type_ARRAYSIZE = message_type_MAX + 1;

PROTO_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* message_type_descriptor();
template<typename T>
inline const std::string& message_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, message_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function message_type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    message_type_descriptor(), enum_t_value);
}
inline bool message_type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, message_type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<message_type>(
    message_type_descriptor(), name, value);
}
enum message_id : int {
  id_none = 0,
  id_ping_req = 1,
  id_ping_ack = 4097,
  id_login_req = 2,
  id_login_ack = 4098,
  id_match_req = 3,
  id_match_ack = 4099,
  id_enter_room_req = 4,
  id_enter_room_ack = 4100,
  id_move_req = 5,
  id_move_ack = 4101,
  id_move_brd = 12293,
  id_s_ping_req = 16385,
  id_s_ping_ack = 20481,
  id_s_gate_register_req = 16386,
  id_s_gate_register_ack = 20482,
  id_s_gate_register_brd = 24578,
  id_s_service_register_req = 16387,
  id_s_service_register_ack = 20483,
  id_s_service_update_req = 16388,
  id_s_service_update_ack = 20484,
  id_s_gate_forward_brd = 24581,
  id_s_service_subscribe_req = 16390,
  id_s_service_subscribe_ack = 20486,
  id_s_service_subscribe_brd = 24582,
  message_id_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  message_id_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
PROTO_API bool message_id_IsValid(int value);
constexpr message_id message_id_MIN = id_none;
constexpr message_id message_id_MAX = id_s_service_subscribe_brd;
constexpr int message_id_ARRAYSIZE = message_id_MAX + 1;

PROTO_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* message_id_descriptor();
template<typename T>
inline const std::string& message_id_Name(T enum_t_value) {
  static_assert(::std::is_same<T, message_id>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function message_id_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    message_id_descriptor(), enum_t_value);
}
inline bool message_id_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, message_id* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<message_id>(
    message_id_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace game

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::game::message_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::message_type>() {
  return ::game::message_type_descriptor();
}
template <> struct is_proto_enum< ::game::message_id> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::message_id>() {
  return ::game::message_id_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_msg_5fid_2eproto
